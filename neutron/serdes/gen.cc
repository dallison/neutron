
#include "neutron/serdes/gen.h"
#include "absl/container/flat_hash_set.h"
#include "absl/strings/str_format.h"
#include "neutron/common_gen.h"
#include "neutron/descriptor.h"
#include "neutron/md5.h"
#include <fstream>

namespace neutron::serdes {

std::string Generator::Namespace(bool prefix_colon_colon) {
  std::string ns;
  if (namespace_.empty()) {
    return ns;
  }
  if (prefix_colon_colon) {
    ns = "::";
  }
  ns += namespace_;
  if (!prefix_colon_colon) {
    ns += "::";
  }
  return ns;
}

absl::Status Generator::Generate(const Message &msg) {
  std::filesystem::path dir =
      root_ / std::filesystem::path(msg.GetPackage()->Name());
  if (!std::filesystem::exists(dir) &&
      !std::filesystem::create_directories(dir)) {
    return absl::InternalError(
        absl::StrFormat("Unable to create directory %s", dir.string()));
  }

  std::filesystem::path header = dir / std::filesystem::path(msg.Name() + ".h");
  std::filesystem::path source =
      dir / std::filesystem::path(msg.Name() + ".cc");

  std::ofstream out(header.string());
  if (!out) {
    return absl::InternalError(
        absl::StrFormat("Unable to create %s", header.string()));
  }
  if (absl::Status status = GenerateHeader(msg, out); !status.ok()) {
    return status;
  }
  std::cout << "Generated header file " << header.string() << std::endl;

  {
    std::ofstream out(source.string());
    if (!out) {
      return absl::InternalError(
          absl::StrFormat("Unable to create %s", source.string()));
    }
    if (absl::Status status = GenerateSource(msg, out); !status.ok()) {
      return status;
    }
    std::cout << "Generated source file " << source.string() << std::endl;
  }

  return absl::OkStatus();
}

static int EnumCSize(const Message &msg) {
  // Look for the biggest constant type.

  int size = 0;
  for (auto & [ name, c ] : msg.Constants()) {
    switch (c->Type()) {
    case FieldType::kInt8:
    case FieldType::kUint8:
      size = std::max(size, 1);
      break;
    case FieldType::kInt16:
    case FieldType::kUint16:
      size = std::max(size, 2);
      break;
    case FieldType::kInt32:
    case FieldType::kUint32:
      size = std::max(size, 4);
      break;
    case FieldType::kInt64:
    case FieldType::kUint64:
      size = std::max(size, 8);
      break;
    default:
      break;
    }
  }
  return size;
}

static std::string EnumCType(const Message &msg) {
  int size = EnumCSize(msg);

  switch (size) {
  case 0:
  default:
    return "uint8_t";
  case 1:
    return "uint8_t";
  case 2:
    return "uint16_t";
  case 4:
    return "uint32_t";
  case 8:
    return "uint64_t";
  }
}

static std::string FieldCType(FieldType type) {
  switch (type) {
  case FieldType::kInt8:
    return "int8_t";
  case FieldType::kUint8:
    return "uint8_t";
  case FieldType::kInt16:
    return "int16_t";
  case FieldType::kUint16:
    return "uint16_t";
  case FieldType::kInt32:
    return "int32_t";
  case FieldType::kUint32:
    return "uint32_t";
  case FieldType::kInt64:
    return "int64_t";
  case FieldType::kUint64:
    return "uint64_t";
  case FieldType::kFloat32:
    return "float";
  case FieldType::kFloat64:
    return "double";
  case FieldType::kTime:
    return "neutron::Time";
  case FieldType::kDuration:
    return "neutron::Duration";
  case FieldType::kString:
    return "std::string";
  case FieldType::kBool:
    return "uint8_t";
  case FieldType::kMessage:
    std::cerr << "Can't use message field type here\n";
    return "<message>";
  case FieldType::kUnknown:
    std::cerr << "Unknown field type " << int(type) << std::endl;
    abort();
  }
}

static std::string SanitizeFieldName(const std::string &name) {
  return name + (IsCppReservedWord(name) ? "_" : "");
}

std::string
Generator::MessageFieldTypeName(const Message &msg,
                                std::shared_ptr<MessageField> field) {
  std::string name;
  if (field->MsgPackage().empty()) {
    return msg.GetPackage()->Name() + "::" + Namespace(false) + field->MsgName();
  }
  return field->MsgPackage() + "::" + Namespace(false) + field->MsgName();
}

static std::string
MessageFieldIncludeFile(const Message &msg,
                        std::shared_ptr<MessageField> field) {
  if (field->MsgPackage().empty()) {
    return "serdes/" + msg.GetPackage()->Name() + "/" + field->MsgName() + ".h";
  }
  return "serdes/" + field->MsgPackage() + "/" + field->MsgName() + ".h";
}

std::shared_ptr<Field> Generator::ResolveField(std::shared_ptr<Field> field) {
  if (field->IsArray()) {
    auto array = std::static_pointer_cast<ArrayField>(field);
    return array->Base();
  }
  return field;
}

// Magic helper templates for std::visit.
// See https://en.cppreference.com/w/cpp/utility/variant/visit
template <class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template <class... Ts> overloaded(Ts...)->overloaded<Ts...>;

absl::Status Generator::GenerateHeader(const Message &msg, std::ostream &os) {
  os << "// File was generated by Neutron "
        "(https://github.com/dallison/neutron)\n";
  os << "// It's probably best not to modify it, but I can't stop you\n";
  os << "#pragma once\n";
  os << "#include \"" << (runtime_path_.empty() ? "" : (runtime_path_ + "/"))
     << "neutron/serdes/runtime.h\"\n";
  os << "#include \"" << (runtime_path_.empty() ? "" : (runtime_path_ + "/"))
     << "neutron/serdes/mux.h\"\n";
  os << "\n";
  // Include files for message fields
  absl::flat_hash_set<std::string> hdrs;
  for (auto field : msg.Fields()) {
    field = ResolveField(field);
    if (field->Type() == FieldType::kMessage) {
      auto msg_field = std::static_pointer_cast<MessageField>(field);
      std::string hdr = MessageFieldIncludeFile(msg, msg_field);
      if (hdrs.contains(hdr)) {
        continue;
      }
      hdrs.insert(hdr);
      os << "#include \"" << (msg_path_.empty() ? "" : (msg_path_ + "/")) << hdr
         << "\"\n";
    }
  }
  os << "\n";
  os << "namespace " << msg.GetPackage()->Name() << Namespace(true) << " {\n";

  if (msg.IsEnum()) {
    // Enumeration.
    if (absl::Status status = GenerateEnum(msg, os); !status.ok()) {
      return status;
    }
  } else {
    if (absl::Status status = GenerateStruct(msg, os); !status.ok()) {
      return status;
    }
  }

  os << "}    // namespace " << msg.GetPackage()->Name() << Namespace(true)
     << "\n";

  return absl::OkStatus();
}

absl::Status Generator::GenerateEnum(const Message &msg, std::ostream &os) {
  os << "enum class " << msg.Name() << " : " << EnumCType(msg) << " {\n";
  for (auto & [ name, c ] : msg.Constants()) {
    os << SanitizeFieldName(c->Name()) << " = " << std::get<0>(c->Value())
       << ",\n";
  }
  os << "};\n";
  return absl::OkStatus();
}

absl::Status Generator::GenerateStruct(const Message &msg, std::ostream &os) {
  os << "struct " << msg.Name()
     << " : public ::neutron::serdes::SerdesMessage {\n";

  // Constants.
  for (auto & [ name, c ] : msg.Constants()) {
    if (c->Type() == FieldType::kString) {
      os << "  static inline constexpr const char "
         << SanitizeFieldName(c->Name()) << "[] = ";
    } else {
      os << "  static constexpr " << FieldCType(c->Type()) << " "
         << SanitizeFieldName(c->Name()) << " = ";
    }

    std::visit(overloaded{[&os](int64_t v) { os << v; },
                          [&os](double v) { os << v; },
                          [&os](std::string v) { os << '"' << v << '"'; }},
               c->Value());
    os << ";" << std::endl;
  }

  os << std::endl;

  for (auto &field : msg.Fields()) {
    if (field->Type() == FieldType::kMessage) {
      auto msg_field = std::static_pointer_cast<MessageField>(field);
      os << "  " << MessageFieldTypeName(msg, msg_field);
    } else if (field->IsArray()) {
      auto array = std::static_pointer_cast<ArrayField>(field);
      const char *container =
          array->IsFixedSize() ? "std::array" : "std::vector";
      os << "  " << container << "<";
      if (array->Base()->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(array->Base());
        os << MessageFieldTypeName(msg, msg_field);
      } else {
        os << FieldCType(array->Base()->Type());
      }
      if (array->IsFixedSize()) {
        os << ", " << array->Size();
      }
      os << ">";
    } else {
      os << "  " << FieldCType(field->Type());
    }
    os << " " << SanitizeFieldName(field->Name()) << " = {};\n";
  }
  os << "\n";
  os << "  static const char* Name() { return \"" << msg.Name() << "\"; }\n";
  os << "  static const char* FullName() { return \"" << msg.GetPackage()->Name()
     << "/" << msg.Name() << "\"; }\n";
  os << "  absl::Status SerializeToArray(char* addr, size_t len, bool "
        "compact=false) const;\n";
  os << "  absl::Status SerializeToBuffer(neutron::serdes::Buffer& buffer, "
        "bool compact = false) "
        "const;\n";
  os << "  absl::Status DeserializeFromArray(const char* addr, size_t "
        "len, bool compact = false);\n";
  os << "  absl::Status DeserializeFromBuffer(neutron::serdes::Buffer& "
        "buffer, bool compact = false);\n";
  os << "  size_t SerializedSize() const;\n";
  os << "  size_t CompactSerializedSize() const;\n";
  os << "  void CompactSerializedSize(neutron::serdes::SizeAccumulator& acc) "
        "const;\n";
  os << "  absl::Status WriteToBuffer(neutron::serdes::Buffer& buffer) "
        "const;\n";
  os << "  absl::Status WriteCompactToBuffer(neutron::serdes::Buffer& buffer, "
        "bool internal = false) "
        "const;\n";
  os << "  absl::Status ReadFromBuffer(neutron::serdes::Buffer& "
        "buffer);\n";
  os << "  absl::Status ReadCompactFromBuffer(neutron::serdes::Buffer& "
        "buffer);\n";
  os << "  static absl::Status Expand(const neutron::serdes::Buffer& src, "
        "neutron::serdes::Buffer& dest);\n";
  os << "  static absl::Status Compact(const neutron::serdes::Buffer& "
        "src, "
        "neutron::serdes::Buffer& dest, bool internal = false);\n";
  os << "  bool operator==(const " << msg.Name() << "& m) const;\n";
  os << "  bool operator!=(const " << msg.Name() << "& m) const {\n";
  os << "    return !this->operator==(m);\n";
  os << "  }\n";
  os << "  std::string DebugString() const;\n";
  os << "  static constexpr unsigned char _descriptor[] = {\n";
  absl::StatusOr<descriptor::Descriptor> desc = MakeDescriptor(msg);
  if (!desc.ok()) {
    return desc.status();
  }
  if (absl::Status status = EncodeDescriptorAsHex(*desc, 80, true, os);
      !status.ok()) {
    return status;
  }
  os << "  };\n";
  os << "  static const std::string MD5() {\n";
  os << "    return \"" << msg.Md5() << "\";\n";
  os << "}\n\n";

  os << "  static absl::Span<const char> GetDescriptor() {\n";
  os << "    return absl::Span<const char>(reinterpret_cast<const "
        "char*>(_descriptor), sizeof(_descriptor));\n";
  os << "  }\n";

  os << " void StreamTo(std::ostream& os) const;\n";

  os << "};\n";

  os << "inline std::ostream& operator<<(std::ostream& os, const " << msg.Name()
     << "& msg) {\n";
  for (auto &field : msg.Fields()) {
    os << "  os << \"" << field->Name() << ": \";\n";
    if (field->Type() == FieldType::kMessage) {
      auto msg_field = std::static_pointer_cast<MessageField>(field);
      if (msg_field->Msg()->IsEnum()) {
        os << "  os << static_cast<" << EnumCType(*msg_field->Msg()) << ">(msg."
           << SanitizeFieldName(field->Name()) << ") << std::endl;\n";
      } else {
        os << "  os << msg." << SanitizeFieldName(field->Name())
           << ".DebugString() << std::endl;\n";
      }
    } else if (field->IsArray()) {
      auto array = std::static_pointer_cast<ArrayField>(field);
      if (array->Base()->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(array->Base());
        os << "  for (auto& m : msg." << SanitizeFieldName(field->Name())
           << ") {\n";
        if (msg_field->Msg()->IsEnum()) {
          os << "    os << " << EnumCType(*msg_field->Msg())
             << "(m) << std::endl;\n";
        } else {
          os << "    os << m.DebugString();\n";
        }
        os << "  }\n";
        os << "  os << std::endl;\n";
      } else {
        auto array = std::static_pointer_cast<ArrayField>(field);
        os << "  for (auto& m : msg." << SanitizeFieldName(array->Name())
           << ") {\n";
        os << "    os << m << std::endl;\n";
        os << "  }\n";
      }
    } else {
      // For int8 and uint8, we want to print as a number, not a character.
      if (field->Type() == FieldType::kInt8 ||
          field->Type() == FieldType::kUint8) {
        os << "  os << static_cast<int>(msg."
           << SanitizeFieldName(field->Name()) << ") << std::endl;\n";
      } else {
        os << "  os << msg." << SanitizeFieldName(field->Name())
           << " << std::endl;\n";
      }
    }
  }
  os << "  return os;\n";
  os << "}\n\n";

  os << "inline void " << msg.Name()
     << "::StreamTo(std::ostream& os) const {\n";
  os << "  os << *this;\n";
  os << "}\n";
  return absl::OkStatus();
}

absl::Status Generator::GenerateSource(const Message &msg, std::ostream &os) {
  os << "#include \"" << (msg_path_.empty() ? "" : (msg_path_ + "/"))
     << "serdes/" << msg.GetPackage()->Name() << "/" << msg.Name() << ".h\"\n";

  if (msg.IsEnum()) {
    return absl::OkStatus();
  }
  os << "namespace " << msg.GetPackage()->Name() << Namespace(true) << " {\n";
  os << "absl::Status " << msg.Name()
     << "::SerializeToArray(char* addr, size_t len, bool compact) const {\n";
  os << "  neutron::serdes::Buffer buffer(addr, len);\n";
  os << "  return SerializeToBuffer(buffer, compact);\n";
  os << "}\n\n";
  os << "absl::Status " << msg.Name()
     << "::DeserializeFromArray(const char* addr, size_t len, bool compact) "
        "{\n";
  os << "  neutron::serdes::Buffer buffer(const_cast<char*>(addr), len);\n";
  os << "  return DeserializeFromBuffer(buffer, compact);\n";
  os << "}\n\n";

  if (absl::Status status = GenerateSerializer(msg, os); !status.ok()) {
    return status;
  }

  if (absl::Status status = GenerateDeserializer(msg, os); !status.ok()) {
    return status;
  }

  if (absl::Status status = GenerateLength(msg, os); !status.ok()) {
    return status;
  }

  if (absl::Status status = GenerateExpanderAndCompactor(msg, os);
      !status.ok()) {
    return status;
  }

  if (absl::Status status = GenerateMux(msg, os); !status.ok()) {
    return status;
  }

  os << "  bool " << msg.Name() << "::operator==(const " << msg.Name()
     << "& m) const {\n";
  for (auto &field : msg.Fields()) {
    os << "  if (this->" << SanitizeFieldName(field->Name()) << " != m."
       << SanitizeFieldName(field->Name()) << ") return false;\n";
  }
  os << "  return true;\n";
  os << "}\n\n";

  os << "std::string " << msg.Name() << "::DebugString() const {\n";
  os << "  std::stringstream s;\n";
  os << "  s << *this;\n";
  os << "  return s.str();\n";
  os << "}\n";
  os << "}    // namespace " << msg.GetPackage()->Name() << Namespace(true)
     << "\n";

  return absl::OkStatus();
}

absl::Status Generator::GenerateSerializer(const Message &msg,
                                           std::ostream &os) {
  os << "absl::Status " << msg.Name()
     << "::SerializeToBuffer(neutron::serdes::Buffer& buffer, bool compact) "
        "const {\n";
  os << "  if (compact) {\n";
  os << "    return WriteCompactToBuffer(buffer);\n";
  os << "  }\n";
  os << "  return WriteToBuffer(buffer);\n";
  os << "}\n\n";

  for (std::string write : {"Write", "WriteCompact"}) {
    bool is_compact = write == "WriteCompact";
    os << "absl::Status " << msg.Name() << "::" << write
       << "ToBuffer(neutron::serdes::Buffer& buffer"
       << (is_compact ? ", bool internal" : "")
       << ") "
          "const {\n";

    for (auto &field : msg.Fields()) {
      if (field->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(field);
        if (msg_field->Msg() == nullptr) {
          abort();
        }
        if (msg_field->Msg()->IsEnum()) {
          os << "  if (absl::Status status = buffer." << write << "("
             << EnumCType(*msg_field->Msg()) << "(this->"
             << SanitizeFieldName(field->Name()) << "))"
             << "; !status.ok()) return status;\n";
        } else {
          os << "  if (absl::Status status = this->"
             << SanitizeFieldName(field->Name()) << "." << write
             << "ToBuffer(buffer" << (is_compact ? ", true" : "") << ")"
             << "; !status.ok()) return status;\n";
        }
      } else if (field->IsArray()) {
        auto array = std::static_pointer_cast<ArrayField>(field);
        if (array->Base()->Type() == FieldType::kMessage) {
          if (!array->IsFixedSize()) {
            os << "  if (absl::Status status = buffer." << write
               << "(uint32_t(this->" << SanitizeFieldName(field->Name())
               << ".size())); !status.ok()) return status;\n";
          }
          auto msg_field =
              std::static_pointer_cast<MessageField>(array->Base());
          os << "  for (auto& m : this->" << SanitizeFieldName(field->Name())
             << ") {\n";
          if (msg_field->Msg()->IsEnum()) {
            os << "    if (absl::Status status = buffer." << write << "("
               << EnumCType(*msg_field->Msg())
               << "(m)); "
                  "!status.ok()) return status;\n";
          } else {
            os << "    if (absl::Status status = m." << write
               << "ToBuffer(buffer" << (is_compact ? ", true" : "") << ")"
               << "; !status.ok()) return status;\n";
          }
          os << "  }\n";
        } else {
          auto array = std::static_pointer_cast<ArrayField>(field);
          os << "  if (absl::Status status = buffer." << write << "(this->"
             << SanitizeFieldName(field->Name())
             << "); !status.ok()) return status;\n";
        }
      } else {
        os << "  if (absl::Status status = buffer." << write << "(this->"
           << SanitizeFieldName(field->Name())
           << "); !status.ok()) return status;\n";
      }
    }
    if (is_compact) {
      os << "  if (!internal) {\n";
      os << "     return buffer.FlushZeroes();\n";
      os << "  }\n";
    }
    os << "  return absl::OkStatus();\n";
    os << "}\n\n";
  }
  return absl::OkStatus();
}

absl::Status Generator::GenerateDeserializer(const Message &msg,
                                             std::ostream &os) {
  os << "absl::Status " << msg.Name()
     << "::DeserializeFromBuffer(neutron::serdes::Buffer& buffer, bool "
        "compact) {\n";
  os << "  if (compact) {\n";
  os << "    if (absl::Status status = ReadCompactFromBuffer(buffer); "
        "!status.ok()) return status;\n";
  os << "  } else {\n";
  os << "    if (absl::Status status =  ReadFromBuffer(buffer); !status.ok()) "
        "return status;\n";
  os << "  }\n";
  os << "    return buffer.CheckAtEnd();\n";
  os << "}\n\n";

  for (std::string read : {"Read", "ReadCompact"}) {
    os << "absl::Status " << msg.Name() << "::" << read
       << "FromBuffer(neutron::serdes::Buffer& buffer) {\n";
    for (auto &field : msg.Fields()) {
      if (field->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(field);
        if (msg_field->Msg()->IsEnum()) {
          os << "  {\n  " << EnumCType(*msg_field->Msg())
             << " v;\n  if (absl::Status status = buffer." << read
             << "(v);"
                "!status.ok()) return status;\n";
          os << "  this->" << SanitizeFieldName(field->Name())
             << " = static_cast<" << MessageFieldTypeName(msg, msg_field)
             << ">(v);\n";
          os << "  }\n";
        } else {
          os << "  if (absl::Status status = this->"
             << SanitizeFieldName(field->Name()) << "." << read
             << "FromBuffer(buffer); !status.ok()) return "
                "status;\n";
        }
      } else if (field->IsArray()) {
        auto array = std::static_pointer_cast<ArrayField>(field);
        if (array->Base()->Type() == FieldType::kMessage) {
          auto msg_field =
              std::static_pointer_cast<MessageField>(array->Base());
          os << "  {\n";
          if (array->IsFixedSize()) {
            os << "    int32_t size = " << array->Size() << ";\n";
          } else {
            os << "    int32_t size;\n";
            os << "    if (absl::Status status = buffer." << read
               << "(size); "
                  "!status.ok()) "
                  "return status;\n";
          }
          os << "    for (int32_t i = 0; i < size; i++) {\n";
          if (msg_field->Msg()->IsEnum()) {
            os << "        " << EnumCType(*msg_field->Msg()) << " v;\n";
            os << "        if (absl::Status status = buffer." << read
               << "(v); "
                  "!status.ok()) "
                  "return status;\n";
            if (array->IsFixedSize()) {
              os << "        this->" << SanitizeFieldName(field->Name())
                 << "[i] = static_cast<" << MessageFieldTypeName(msg, msg_field)
                 << ">(v);\n";
            } else {
              os << "        this->" << SanitizeFieldName(field->Name())
                 << ".push_back(static_cast<"
                 << MessageFieldTypeName(msg, msg_field) << ">(v));\n";
            }
            os << "    }\n";
          } else {
            if (array->IsFixedSize()) {
              os << "      if (absl::Status status = this->"
                 << SanitizeFieldName(field->Name()) << "[i]." << read
                 << "FromBuffer(buffer)"
                 << "; !status.ok()) return status;\n";
              os << "    }\n";
            } else {
              os << "      " << MessageFieldTypeName(msg, msg_field)
                 << " tmp;\n";
              os << "      if (absl::Status status = "
                    "tmp."
                 << read << "FromBuffer(buffer)"
                 << "; !status.ok()) return status;\n";
              os << "      this->" << SanitizeFieldName(field->Name())
                 << ".push_back(std::move(tmp));\n";
              os << "    }\n";
            }
          }
          os << "  }\n";
        } else {
          auto array = std::static_pointer_cast<ArrayField>(field);
          os << "  if (absl::Status status = buffer." << read << "(this->"
             << SanitizeFieldName(field->Name())
             << "); !status.ok()) return status;\n";
        }

      } else {
        os << "  if (absl::Status status = buffer." << read << "(this->"
           << SanitizeFieldName(field->Name())
           << "); !status.ok()) return status;\n";
      }
    }
    os << "  return absl::OkStatus();\n";
    os << "}\n\n";
  }
  return absl::OkStatus();
}

absl::Status Generator::GenerateLength(const Message &msg, std::ostream &os) {
  // Non-compact (ROS) serialized size.
  os << "size_t " << msg.Name() << "::SerializedSize() const {\n";
  os << "  size_t length = 0;\n";
  for (auto &field : msg.Fields()) {
    if (field->Type() == FieldType::kMessage) {
      auto msg_field = std::static_pointer_cast<MessageField>(field);
      if (msg_field->Msg()->IsEnum()) {
        os << "  length += " << EnumCSize(*msg_field->Msg()) << ";\n";
      } else {
        os << "  length += this->" << SanitizeFieldName(field->Name())
           << ".SerializedSize();\n";
      }
    } else if (field->IsArray()) {
      auto array = std::static_pointer_cast<ArrayField>(field);
      if (array->Base()->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(array->Base());
        if (msg_field->Msg()->IsEnum()) {
          os << "  length += " << (array->IsFixedSize() ? 0 : 4) << " + this->"
             << SanitizeFieldName(field->Name()) << ".size() * "
             << EnumCSize(*msg_field->Msg()) << ";\n";
        } else {

          if (!array->IsFixedSize()) {
            os << "  length += 4;\n";
          }
          os << "  for (auto& m : this->" << SanitizeFieldName(field->Name())
             << ") {\n";
          os << "    length += m.SerializedSize();\n";
          os << "  }\n";
        }
      } else {
        if (array->Base()->Type() == FieldType::kString) {
          // Each element is a string with a 4-byte length prefix.
          if (!array->IsFixedSize()) {
            os << "  length += 4;\n";
          }
          os << "  for (auto& s : this->" << SanitizeFieldName(field->Name())
             << ") {\n";
          os << "    length += 4 + s.size();\n";
          os << "  }\n";
        } else {
          os << "  length += " << (array->IsFixedSize() ? 0 : 4) << " + this->"
             << SanitizeFieldName(field->Name()) << ".size() * sizeof("
             << FieldCType(array->Base()->Type()) << ");\n";
        }
      }
    } else {
      if (field->Type() == FieldType::kString) {
        os << "  length += 4 + this->" << SanitizeFieldName(field->Name())
           << ".size();\n";
      } else {
        os << "  length += sizeof(this->" << SanitizeFieldName(field->Name())
           << ");\n";
      }
    }
  }
  os << "  return length;\n";
  os << "}\n\n";

  // Compact serialized size.
  os << "void " << msg.Name()
     << "::CompactSerializedSize(neutron::serdes::SizeAccumulator& acc) const "
        "{\n";
  for (auto &field : msg.Fields()) {
    if (field->Type() == FieldType::kMessage) {
      auto msg_field = std::static_pointer_cast<MessageField>(field);
      if (msg_field->Msg()->IsEnum()) {
        os << "  acc.Accumulate(static_cast<uint64_t>(this->"
           << SanitizeFieldName(field->Name()) << "));\n";
      } else {
        os << "  this->" << SanitizeFieldName(field->Name())
           << ".CompactSerializedSize(acc);\n";
      }
    } else if (field->IsArray()) {
      auto array = std::static_pointer_cast<ArrayField>(field);
      if (array->Base()->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(array->Base());
        if (!array->IsFixedSize()) {
          os << "  acc.Accumulate(" << SanitizeFieldName(field->Name())
             << ".size());\n";
        }
        os << "  for (auto& m : this->" << SanitizeFieldName(field->Name())
           << ") {\n";
        if (msg_field->Msg()->IsEnum()) {
          os << "    acc.Accumulate(static_cast<uint64_t>(m));\n";
        } else {
          os << "    m.CompactSerializedSize(acc);\n";
        }
        os << "  }\n";
      } else {
        os << "  acc.Accumulate(this->" << SanitizeFieldName(field->Name())
           << ");\n";
      }
    } else {
      os << "  acc.Accumulate(this->" << SanitizeFieldName(field->Name())
         << ");\n";
    }
  }
  os << "}\n\n";

  os << "size_t " << msg.Name() << "::CompactSerializedSize() const {\n";
  os << "  neutron::serdes::SizeAccumulator acc;\n";
  os << "  CompactSerializedSize(acc);\n";
  os << "  acc.Close();\n";
  os << "  return acc.Size();\n";
  os << "}\n\n";
  return absl::OkStatus();
}

absl::Status Generator::GenerateExpanderAndCompactor(const Message &msg,
                                                     std::ostream &os) {
  for (std::string func : {"Expand", "Compact"}) {
    bool is_compact = func == "Compact";
    os << "absl::Status " << msg.Name() << "::" << func
       << "(const neutron::serdes::Buffer& src, neutron::serdes::Buffer& "
          "dest"
       << (is_compact ? ", bool internal" : "") << ") {\n";
    for (auto &field : msg.Fields()) {
      if (field->Type() == FieldType::kMessage) {
        auto msg_field = std::static_pointer_cast<MessageField>(field);
        if (msg_field->Msg()->IsEnum()) {
          os << "  if (absl::Status status = src." << func << "<"
             << EnumCType(*msg_field->Msg())
             << ">(dest);"
                "!status.ok()) return status;\n";
        } else {
          os << "  if (absl::Status status = "
             << MessageFieldTypeName(msg, msg_field) << "::" << func
             << "(src, dest" << (is_compact ? ", true" : "")
             << "); !status.ok()) return "
                "status;\n";
        }
      } else if (field->IsArray()) {
        auto array = std::static_pointer_cast<ArrayField>(field);
        if (array->Base()->Type() == FieldType::kMessage) {
          auto msg_field =
              std::static_pointer_cast<MessageField>(array->Base());
          os << "  {\n";
          // Declare a size variable.
          if (array->IsFixedSize()) {
            os << "    uint32_t size = " << array->Size() << ";\n";
          } else {
            os << "    uint32_t size;\n";
            if (func == "Expand") {
              os << "    if (absl::Status status = "
                    "src.ReadUnsignedLeb128(size); "
                    "!status.ok()) return status;\n";

              os << "    if (absl::Status status = dest.Write(size); "
                    "!status.ok()) return status;\n";
            } else {
              os << "    if (absl::Status status = src.Read(size); "
                    "!status.ok()) return status;\n";
              os << "    if (absl::Status status = "
                    "dest.WriteUnsignedLeb128(size); !status.ok()) return "
                    "status;\n";
            }
          }

          os << "    for (size_t i = 0; i < size_t(size); i++) {\n";

          if (msg_field->Msg()->IsEnum()) {
            // Array or vector of enums
            os << "      if (absl::Status status = src." << func << "<"
               << EnumCType(*msg_field->Msg())
               << ">(dest); "
                  "!status.ok())\n";
            os << "        return status;\n";
          } else {
            // Array or vector of messages.
            os << "      if (absl::Status status = "
               << MessageFieldTypeName(*msg_field->Msg(), msg_field)
               << "::" << func << "(src, dest" << (is_compact ? ", true" : "")
               << "); !status.ok())\n";
            os << "        return status;\n";
          }
          os << "    }\n"; // Close for loop
          os << "  }\n";   // Close scope
        } else {
          // Array or vector of simple types.
          std::string vec_type =
              array->IsFixedSize() ? "std::array" : "std::vector";
          std::string array_size = array->IsFixedSize()
                                       ? absl::StrFormat(", %d", array->Size())
                                       : "";
          auto array = std::static_pointer_cast<ArrayField>(field);
          os << "  if (absl::Status status = src." << func << "(" << vec_type
             << "<" << FieldCType(array->Base()->Type()) << array_size
             << ">(), dest); !status.ok()) return status;\n";
        }

      } else {
        os << "  if (absl::Status status = src." << func << "<"
           << FieldCType(field->Type())
           << ">(dest); !status.ok()) return status;\n";
      }
    }
    if (is_compact) {
      os << "  if (!internal) {\n";
      os << "    return dest.FlushZeroes();\n";
      os << "  }\n";
    }
    os << "  return absl::OkStatus();\n";
    os << "}\n\n";
  }
  return absl::OkStatus();
}

absl::Status Generator::GenerateMux(const Message &msg, std::ostream &os) {
  std::string msg_name = msg.Name();
  os << "static absl::Span<const char> " << msg_name
     << "GetDescriptor() "
        "{\n";
  os << "  return " << msg_name << "::GetDescriptor();\n";
  os << "}\n\n";

  os << "static absl::Status " << msg_name
     << "SerializeToArray(const ::neutron::serdes::SerdesMessage& msg, char* "
        "buf, size_t size, bool compact) "
        "{\n";
  os << "  const " << msg_name << " *m = static_cast<const " << msg_name
     << "*>(&msg);\n";
  os << "  return m->SerializeToArray(buf, size, compact);\n";
  os << "}\n\n";

  os << "static absl::Status " << msg_name
     << "SerializeToBuffer(const ::neutron::serdes::SerdesMessage& msg, "
        "::neutron::serdes::Buffer& buffer, bool compact) "
        "{\n";
  os << "  const " << msg_name << " *m = static_cast<const " << msg_name
     << "*>(&msg);\n";
  os << "  return m->SerializeToBuffer(buffer, compact);\n";
  os << "}\n\n";

  os << "static absl::Status " << msg_name
     << "DeserializeFromArray(::neutron::serdes::SerdesMessage& msg, const "
        "char* buf, size_t size, bool compact) "
        "{\n";
  os << "  " << msg_name << " *m = static_cast<" << msg_name << "*>(&msg);\n";
  os << "  return m->DeserializeFromArray(buf, size, compact);\n";
  os << "}\n\n";

  os << "static absl::Status " << msg_name
     << "DeserializeFromBuffer(::neutron::serdes::SerdesMessage& msg, "
        "::neutron::serdes::Buffer& buffer, bool compact) "
        "{\n";
  os << "  " << msg_name << " *m = static_cast<" << msg_name << "*>(&msg);\n";
  os << "  return m->DeserializeFromBuffer(buffer, compact);\n";
  os << "}\n\n";

  os << "static size_t " << msg_name
     << "SerializedSize(const ::neutron::serdes::SerdesMessage& msg) "
        "{\n";
  os << "  const " << msg_name << " *m = static_cast<const " << msg_name
     << "*>(&msg);\n";
  os << "  return m->SerializedSize();\n";
  os << "}\n\n";

  os << "static size_t " << msg_name
     << "CompactSerializedSize(const ::neutron::serdes::SerdesMessage& msg) "
        "{\n";
  os << "  const " << msg_name << " *m = static_cast<const " << msg_name
     << "*>(&msg);\n";
  os << "  return m->CompactSerializedSize();\n";
  os << "}\n\n";

  os << "static void " << msg_name
     << "StreamTo(const ::neutron::serdes::SerdesMessage& msg, std::ostream& "
        "os) "
        "{\n";
  os << "  const " << msg_name << " *m = static_cast<const " << msg_name
     << "*>(&msg);\n";
  os << "  m->StreamTo(os);\n";
  os << "}\n\n";

  os << "static std::string " << msg_name
     << "DebugString(const ::neutron::serdes::SerdesMessage& msg) "
        "{\n";
  os << "  const " << msg_name << " *m = static_cast<const " << msg_name
     << "*>(&msg);\n";
  os << "  return m->DebugString();\n";
  os << "}\n\n";

  os << "static absl::Status " << msg_name
     << "Expand(const ::neutron::serdes::Buffer& src, "
        "::neutron::serdes::Buffer& dest) "
        "{\n";
  os << "  return " << msg_name << "::Expand(src, dest);\n";
  os << "}\n\n";

  os << "static absl::Status " << msg_name
     << "Compact(const ::neutron::serdes::Buffer& src, "
        "::neutron::serdes::Buffer& dest) "
        "{\n";
  os << "  return " << msg_name << "::Compact(src, dest, false);\n";
  os << "}\n\n";

  os << "static ::neutron::serdes::MessageMetadata " << msg_name
     << "Metadata = {\n";
  os << "  .get_descriptor = " << msg_name << "GetDescriptor,\n";

  os << "  .serialize_to_array = " << msg_name << "SerializeToArray,\n";
  os << "  .serialize_to_buffer = " << msg_name << "SerializeToBuffer,\n";
  os << "  .deserialize_from_array = " << msg_name << "DeserializeFromArray,\n";
  os << "  .deserialize_from_buffer = " << msg_name
     << "DeserializeFromBuffer,\n";
  os << "  .serialized_size = " << msg_name << "SerializedSize,\n";
  os << "  .compact_serialized_size = " << msg_name
     << "CompactSerializedSize,\n";
  os << "   .debug_string = " << msg_name << "DebugString,\n";
  os << "   .stream_to = " << msg_name << "StreamTo,\n";
  os << "   .compact = " << msg_name << "Compact,\n";
  os << "   .expand = " << msg_name << "Expand,\n";
  os << "};\n\n";

  os << "static struct " << msg_name << "MuxInitializer {\n";
  os << "  " << msg_name << "MuxInitializer() {\n";
  os << "    ::neutron::serdes::MessageMux::Instance().Register(" << msg_name
     << "::FullName(), " << msg_name << "Metadata);\n";
  os << "  }\n";
  os << "} " << msg_name << "MuxInitializer;\n";
  return absl::OkStatus();
}
} // namespace neutron::serdes
